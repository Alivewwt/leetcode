package project.leetcode;
//思路
/*
 * 二叉搜索树有个性质，就是左边的数比根节点小，右边的数比根节点大。题目说明二叉树的节点是从1到n，所以我们能确定如果根为k，根左边
 * 的数是1到k-1，根右边的数是k+1到n.还有一点技巧是，对于通过一个根来说，唯一二叉树的数量是其左子树的数量乘以右子树的数量。并且，
 * 左右子树的形态数量是跟具体的数无关的，只跟这个树里有多少节点有关。而跟可以选择从1到n的任意的数，唯一二叉树的总数，就是根为1到n
 * 的树相加。所有该问题简化为以k为根，其唯一左子树和右子树各有多少，这就是个动态规划的问题了。我们建立一个数组dp[i],代表节点数为i的唯一子树有多少个
 * ，显然dp[0]=dp[1]
 * d[2]=d[0]*d[1] (根为1)
 * 		+d[1]*d[0] (根为2)
 */
public class numTrees {
	public int numsTree(int n){
		int[] dp=new int[n+1];
		dp[0]=dp[1]=1;
		//从节点数2开始计算到节点数为n的BST
		for(int i=2;i<n+1;i++){
			for(int j=0;j<i;j++){
				dp[i]+=dp[j]*dp[i-j-1];
			}
		}
		return dp[n];
	}
}