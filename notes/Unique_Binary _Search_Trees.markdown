### 题目描述：

给定n个节点，可以组成多个二叉查找树(中序遍历二叉树可得到一个关键字的有序序列).

假设n=3,如下总共有5个二叉查找树

>```tex
>   1         3     3      2      1
>    \       /     /      / \      \
>     3     2     1      1   3      2
>    /     /       \                 \
>   2     1         2                 3
>```

### 思路:

这道题实际上是卡特兰数的一个例子。如果对卡特兰数不熟悉的同学可能真不太好做。我们先来看当n=1的情况，只能形成唯一的一棵二叉搜索树，n为1,2,3的情况如下所示:

>```tex
>1                        n = 1
>
>                2        1                  n=2
>               /          \
>              1            2
>  
>   1         3     3      2      1           n=3
>    \       /     /      / \      \
>     3     2     1      1   3      2
>    /     /       \                 \
>   2     1         2                 3
>```

跟斐波那契数列一样，我们把n=0时赋为1，因为空树也算一种二叉搜索树，那么n=1的情况可以看做是其左子树乘以右子树的个数，左右子树都是空树，所以1*1=1.那么n=2时，由于1和2都可以为根，分别算出来，再把它们加起来即可。n=2的情况可由下面式子算出:

dp[2]=dp[0]*dp[1]	（1为根的情况）

​	 +dp[1]*dp[0]	（2为根的情况）

同理可以写出n=3的计算方法：

dp[3]=dp[0]*dp[2]	（1为根的情况）

​	+dp[1]*dp[1]		（2为根的情况）

​	+dp[2]*dp[0]		（3为根的情况）

由此可以得出卡特兰数的递推公式：

$$C_0=1 and C_{n+1}=\sum^n_{i=0}C_iC_{n-i}   for n\geq0$$  

代码如下：

>```java
>public int numsTree(int n){
>	int[] dp=new int[n+1];
>	dp[0]=dp[1]=1;
>	//从节点数2开始计算到节点数为n的BST
>	for(int i=2;i<n+1;i++){
>		for(int j=0;j<i;j++){
>			dp[i]+=dp[j]*dp[i-j-1];
>		}
>	}
>	return dp[n];
>}
>```

